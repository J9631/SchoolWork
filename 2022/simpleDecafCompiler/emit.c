/*
    Jacob Sanchez
    October 31, 2022
    CS 370, LAB9

	The C code below utilizes the AST generated by the semantic action in YACC after parsing provided decaf code to produce
	GAS code in a .s file that can be compiled and run with the functionality of the decaf code.
*/

#include <string.h>
#include "emit.h"
#include "ast.h"

#define WSIZE 8 //The wordsize in bytes
#define LOG_WSIZE 3 //2 to the 3 is 8

//Internal Prototypes -- methods exclusively used in emit.c
void Emit_Globals(ASTnode *p, FILE *fp);
void Emit_Strings(ASTnode *p, FILE *fp);
void Emit_AST(ASTnode *p, FILE *fp);
void Emit_Method_Decl(ASTnode *p, FILE *fp);
void emit(FILE *fp, char *label, char *action, char *comment);
void Emit_Return(ASTnode *p, FILE *fp);
void Emit_Expr(ASTnode *p, FILE *fp);
void Emit_Method_Call(ASTnode *p, FILE *fp);
void Emit_Extern_Method_Call(ASTnode *p, FILE *fp);
void Emit_Assign(ASTnode *p, FILE *fp);
void Emit_Ident(ASTnode *p, FILE *fp);
void Emit_If(ASTnode *p, FILE *fp);
void Emit_While(ASTnode *p, FILE *fp);
void Emit_Operation(ASTnode *p, FILE *fp);
void Emit_Break(ASTnode *p, FILE *fp);
void Emit_Continue(ASTnode *p, FILE *fp);

//Linked List of labels that will function as a STACK for labels
struct LabelList{
    char* label;
    struct LabelList* next;
};

struct LabelList* GOBACK = NULL; //GLOBAL stack for labels at start of WHILE for CONTINUE
struct LabelList* GETOUT = NULL; //GLOBAL stack for labels at end of WHILE for BREAK


//PRE: PTR to a label and a LabelList stack.
//POST: A new Label is pushed on top of the stack
struct LabelList* Push_Label(char* label, struct LabelList* target){

    //Declares and allocates memory for a new LabelList struct
    struct LabelList* ptr;
    ptr = (struct LabelList*)(malloc(sizeof(struct LabelList)));

    ptr->label = label;
    ptr->next = target; //Puts ptr "on top" of the stack by linking it to the previous top;

    return ptr;
}//end Push_Label


int GLABEL = 0; //One up number for creating labels

//PRE: none
//POST: A label string in the format_Ln where n is an integer, is returned.
char* gen_Label(){
  char s[100];
  sprintf(s, "_L%d", GLABEL);
  GLABEL++;
  return(strdup(s));
}//end gen_Label()


//PRE: Pointers to AST tree and opened filed
//POST: GAS code in fp that implements the tree
void EMIT(ASTnode *p, FILE *fp){
    //Print name of package
    fprintf(fp, "#   Package %s\n", p->S2->name);
    fprintf(fp, "\n");
    fprintf(fp, "\t.section .rodata # start of the RODATA section, strings first\n\n");

    fprintf(fp, "percentD: .string \"%%d\" # ALWAYS needed for print int\n\n");

    fprintf(fp, "# NEXT lines are all the strings in the program\n");

    Emit_Strings(p, fp);

    fprintf(fp, "\n# End of print all the strings in the program\n\n");

    //DATA section
    fprintf(fp, "\t.data # start of the DATA section for varaibles\n\n");

    //Necessary space for scanf, mandatory in EVERY program
    fprintf(fp, "\t.comm _SCANFHOLD,8,8 # MANDATORY space for SCANF reads\n");
    fprintf(fp, "\t.align 8\n\n");

    Emit_Globals(p, fp);

    fprintf(fp, "\n# End of the DATA section for variables\n\n");

    //CODE section
    fprintf(fp, "\t\t.text    #start of CODE segment \n");

    fprintf(fp, "\n");

    //Begin to write rest of GAS code for tree
    Emit_AST(p->S2, fp);

    fprintf(fp, "\n");
    emit(fp, NULL, ".ident \"GCC: (SUSE Linux) 7.5.0\"", NULL);
    emit(fp, NULL, ".section     .note.GNU-stack,\"\", @progbits", NULL);
}




//PRE: none
//POST: Prints all strings inside tree with generated one-up labels
void Emit_Strings(ASTnode *p, FILE *fp){
    if(p == NULL) return;

    if( (p->type == A_CONSTANT_STRING) ){
        char *s = strdup(p->name);  //Duplicates string
        char *label = gen_Label();  //Creates a one-up label for this string
        fprintf(fp, "%s:\t.string %s\t#Global String\n", label, s);
        p->label = strdup(label);   //Sets the label inside of the node to the generated label
    }

    //Cruises rest of tree looking for strings
    Emit_Strings(p->S1, fp);
    Emit_Strings(p->S2, fp);
    Emit_Strings(p->next, fp);
}//end Emit_Strings




//PRE: PTR to AST and open file
//POST GAS code for GLOBAL variable to be placed in .data section
void Emit_Globals(ASTnode *p, FILE *fp){
    if(p == NULL) return;

    //Checks that node is a variable on level 0 which confirms its a global var
    if( (p->type == A_VARDEC) && (p->symbol->level == 0) ){
        //Checks if the globa variable is assigned, assignment is S2 connected to node.
        if(p->S2 == NULL)
            fprintf(fp, "\t.comm %s,%d,%d # define a global variable\n", p->name, p->symbol->mysize * WSIZE, p->symbol->mysize * WSIZE);
        else
            fprintf(fp, "%s:     .long %d # define a global variable with initial value\n", p->name, p->S2->value);
        fprintf(fp, "\t.align 8\n\n"); //Aligns all global variables that are declared
    }//end of global variable match

    //Cruises entire tree to print out globals
    Emit_Globals(p->S1, fp);
    Emit_Globals(p->S2, fp);
    Emit_Globals(p->next, fp);
}//end Emit_Globals




//PRE: PTR to AST and open FILE
//POST: GAS code that generates all the GAS elements for the rest of the tree
void Emit_AST(ASTnode *p, FILE *fp){
    if(p == NULL) return;

    switch(p->type) {
        //Package is handled before Emit_AST just continues onto its nodes
        case A_PACKAGE: Emit_AST(p->S1, fp);
                        Emit_AST(p->S2, fp);
                        Emit_AST(p->next, fp);
                        break;

        //Externs are handled elsewhere so they are completely skipped
        case A_EXTERN: break;
        case A_EXTERN_TYPE: break;
        
        //A_VARDEC also skipped since globals are handled before Emit_AST
        case A_VARDEC: break;
        
        case A_METHODDEC: Emit_Method_Decl(p, fp);
                          Emit_AST(p->next, fp); //Methods are next connected
                          break;

        case A_BLOCK: Emit_AST(p->S2, fp);   //Gets the internals of the Block
                      Emit_AST(p->next, fp); //Blocks themeselves can be next connected
                      break;

        case A_IF: Emit_If(p, fp);
                   Emit_AST(p->next, fp);
                   break;

        case A_WHILESTMT: Emit_While(p, fp);
                      Emit_AST(p->next, fp);
                      break;

        case A_METHOD_CALL: Emit_Method_Call(p, fp);
                            Emit_AST(p->next, fp);
                            break;

        case A_RETURN:  Emit_Return(p, fp);
                        Emit_AST(p->next, fp); //Nodes inside block next connected
                        break;

        case A_ASSIGN:  Emit_Assign(p, fp);
                        Emit_AST(p->next, fp); //Assings can be followed by anything
                        break;

        case A_CONTINUE: Emit_Continue(p, fp);
                         Emit_AST(p->next, fp);
                         break;

        case A_BREAK: Emit_Break(p, fp);
                      Emit_AST(p->next, fp);
                      break;


        //"Error message" that prints if a nodetype is found with no rule
        default: printf("WARNING EMIT_AST SHOULD NEVER NEVER NEVER BE HERE FIX FIX FIX %d\n", p->type);
    }//end switch
}//end Emit_AST()



//PRE: PTR to ASTnode that points to a Continue
//POST: GAS code to jump to start of current loop
void Emit_Continue(ASTnode *p, FILE *fp){
    char s[100]; //Dynamically created string for emit()
    sprintf(s, "jmp %s", GOBACK->label);
    emit(fp, NULL, s, "Continue Statement");
}//end Emit_Continue



//PRE: PTR to ASTnode that points to a Break
//POST: GAS code to exit the current loop
void Emit_Break(ASTnode *p, FILE *fp){
    char s[100]; //Dynamically created strings for emit()
    sprintf(s, "jmp %s", GETOUT->label);
    emit(fp, NULL, s, "Break Statement");
}//end Emit_Break



//PRE: PTR to AST node that points to Method Declation and PTR open fp
//POST: GAS code for the method
void Emit_Method_Decl(ASTnode *p, FILE *fp){

    char s[100]; //dynamic string creation

    fprintf(fp, "\t\t.globl %s \n", p->name);
    fprintf(fp, "\t\t.type %s, @function\n", p->name);
    emit(fp, p->name, NULL, "Start of Function\n");
    //fprintf(fp, "%s:      # Start of Function\n\n", p->name);

    //Following lines generate the standard function header all methods have in GAS code
    fprintf(fp, "\t.cfi_startproc \t# STANDARD FUNCTION HEADER FOR GAS \n");
    fprintf(fp, "\tpushq %%rbp  \t# STANDARD FUNCTION HEADER FOR GAS \n");
    fprintf(fp, "\t.cfi_def_cfa_offset 16  # STANDARD FUNCTION HEADER FOR GAS \n");
    fprintf(fp, "\t.cfi_offset 6, -16      # STANDARD FUNCTION HEADER FOR GAS \n");
    fprintf(fp, "\tmovq  %%rsp, %%rbp        # STANDARD FUNCTION HEADER FOR GAS \n");
    fprintf(fp, "\t.cfi_def_cfa_register 6 # STANDARD FUNCTION HEADER FOR GAS \n");

    fprintf(fp, "\n\n");

    sprintf(s, "subq $%d, %%rsp", p->size * WSIZE); //Line rights gas code that "Carves out room on stack" onto created string
    emit(fp, NULL, s, "Carve out Stack for method");

    ASTnode *params = p->S1;
    int IO2 = -1; //Counter for param list starts at -1, because 1 element should correspond to an index of 0

    //Cruises through the param list once to get its size
    while(params != NULL){
        params = params->next;
        IO2++;
    }//end while

    params = p->S1;
    int IO = 0; //Counter for the registers being used, starts at 8 + 0

    //Cruises through the param list again to copy the actuals to their appropriate slots in memory
    while(params != NULL){
        fprintf(fp, "\tmov %r%d, %d(%rsp)\t# Copy actual to appropriate slot\n", IO + 8, IO2 * WSIZE);
        params = params->next;
        IO++;
        IO2--;
    }//end while

    Emit_AST(p->S2, fp); //Prints out GAS for Body of Method

    fprintf(fp, "\n"); //whitespace to separate methods

    //Implicit Return
    Emit_Return(NULL, fp);

    fprintf(fp, "\n");

    emit(fp, NULL, ".cfi_endproc", "STANDARD end function for GAS");

    sprintf(s, ".size %s, .-%s", p->name, p->name);
    emit(fp, NULL, s, "STANDARD end function for GAS");

    fprintf(fp, "\n");

}//end Emit_Method_Decl


//PRE: PTR to AST node that points to Return or NULL declaration
//POST: GAS code for the return, %rax is 0 for NULL, set by Emit_Expr() for expression
void Emit_Return(ASTnode *p, FILE *fp){

    //Implicit return for all methods without an expression used for return
    if(p == NULL || p->S1 == NULL)
        emit(fp, NULL, "mov $0, %rax", "Default Return");
    else
        Emit_Expr(p->S1, fp); //Emits the expression in return


    emit(fp, NULL, "leave", "leave the function");
    emit(fp, NULL, ".cfi_def_cfa 7, 8", "STANDARD end function for GAS");
    emit(fp, NULL, "ret", NULL);
}//end Emit_Return




//PRE: PTR to ASTnode that is in the class or EXPRessions including CONSTANTS and Method Call.
//POST: GAS code that sets %rax to the evaluation of the evaluation of the expression.
void Emit_Expr(ASTnode *p, FILE *fp){
    //Should never get NULL here due to preconditions char s[100];
    char s[100]; //Holder to make dynamics commands

    //Base cases
    switch(p->type){

        case A_CONSTANT_INT:
            sprintf(s, "mov $%d, %%rax", p->value);
            emit(fp, NULL, s, "EXPR load constant INT");
            return;
            break;

        case A_CONSTANT_BOOL:
            sprintf(s, "mov $%d, %%rax", p->value);
            emit(fp, NULL, s, "EXPR load constant BOOL");
            return;
            break;

        case A_METHOD_CALL:
            Emit_Method_Call(p, fp);
            return; // %rax is set, so just return
            break;

        case A_VAR_RVALUE:
            Emit_Ident(p, fp); //Memory address of LVALUE loaded onto RAX
            emit(fp, NULL, "mov (%rax), %rax", "Read in memory value");
            return;
            break;

        case A_EXPR: 
            Emit_Operation(p, fp);
            return;
            break;
            
        default:// fall through to recursive case
                break;
    }// End base case switch

}//end Emit_Expr

//PRE: PTR to AST node that contains an operation that needs to be evaluated.
//POST: GAS code that "Unfolds" A_EXPR nodes evaluating their operations.
void Emit_Operation(ASTnode *p, FILE *fp){
    char s[100]; //Dynamically created string for emit()
    
        //Math
    //Evaluate the LHS emit_expr p->S1
    //IF ther is a RHS, save RAX in temp
    //  Evaluate the RHS emit_expr p->S2
    //  MOVE RAX to RBX
    //  Restore the LHS to RAX
    //Do the operation
    
    //Emits then Loads the LHS of an EXPR, always necessary
    Emit_Expr(p->S1, fp);
    fprintf(fp, "\tmov %rax, %d(%rsp)\t#Store LHS of Expression to Memory\n", p->symbol->offset * WSIZE);

    //Unary operator cases handled first before trying to emit p->S2
    switch(p->operator){

        case A_U_MINUS:
            fprintf(fp,"\tmov %d(%rsp), %rax\t#Fetch LHS of Expression from Memory\n", p->symbol->offset * WSIZE);
            emit(fp, NULL, "neg %rax", "Negate RAX");
            return;
            break;

        case A_NOT:
            fprintf(fp,"\tmov %d(%rsp), %rax\t#Fetch LHS of Expression from Memory\n", p->symbol->offset * WSIZE);
            emit(fp, NULL, "subq $1, %rax", "Inverses Truth");
            return;
            break;

        default:
            break;
    }//end of unary switch

    //Emits and sets the RHS of an EXPR, necessary in non-unary operation
    Emit_Expr(p->S2, fp);
    emit(fp, NULL, "mov %rax, %rbx", "right hand side needs to be set");

    fprintf(fp,"\tmov %d(%rsp), %rax\t#Fetch LHS of Expression from Memory\n", p->symbol->offset * WSIZE);

    //All other operator cases
    switch(p->operator){

        case A_PLUS:
            emit(fp, NULL, "add %rbx, %rax", "Adds Expressions");
            return;
            break;

        case A_MINUS:
            emit(fp, NULL, "sub %rbx, %rax", "Subtracts Expressions");
            return;
            break;

        case A_TIMES:
            emit(fp, NULL, "imul %rbx, %rax", "Multiplies Expressions");
            return;
            break;

        case A_DIVIDE:
            emit(fp, NULL, "mov $0, %rdx", "EXPR upper word 0 DIV");
            emit(fp, NULL, "idiv %rbx", "Divides Expressions");
            return;
            break;

        case A_MOD:
            emit(fp, NULL, "mov $0, %rdx", "EXPR upper word 0 DIV");
            emit(fp, NULL, "idiv %rbx", "Divides Expressions");
            emit(fp, NULL, "mov %rdx, %rax", "MOD is stored in RAX");
            return;
            break;

        case A_AND:
            emit(fp, NULL, "and %rbx, %rax", "EXPR AND");
            return;
            break;

        case A_OR:
            emit(fp, NULL, "or %rbx, %rax", "EXPR OR");
            return;
            break;

        case A_LT:
            emit(fp, NULL, "cmp %rbx, %rax", "EXPR lessthan");
            emit(fp, NULL, "setl %al", "EXPR lessthan");
            emit(fp, NULL, "mov $1, %rbx", "set rbx to one to filter rax");
            emit(fp, NULL, "and %rbx, %rax", "filter RAX");
            return;
            break;

        case A_GT:
            emit(fp, NULL, "cmp %rbx, %rax", "EXPR Greaterthan");
            emit(fp, NULL, "setg %al", "EXPR Greaterthan");
            emit(fp, NULL, "mov $1, %rbx", "set rbx to one to filter rax");
            emit(fp, NULL, "and %rbx, %rax", "filter RAX");
            return;
            break;

        case A_GEQ:
            emit(fp, NULL, "cmp %rbx, %rax", "EXPR GE");
            emit(fp, NULL, "setge %al", "EXPR GE");
            emit(fp, NULL, "mov $1, %rbx", "set rbx to one to filter rax");
            emit(fp, NULL, "and %rbx, %rax", "filter RAX");
            return;
            break;

        case A_LEQ:
            emit(fp, NULL, "cmp %rbx, %rax", "EXPR LessEqual");
            emit(fp, NULL, "setle %al", "EXPR Lessthan");
            emit(fp, NULL, "mov $1, %rbx", "set rbx to one to filter rax");
            emit(fp, NULL, "and %rbx, %rax", "filter RAX");
            return;
            break;

        case A_EQ:
            emit(fp, NULL, "cmp %rbx, %rax", "EXPR Equal");
            emit(fp, NULL, "sete %al", "EXPR Equal");
            emit(fp, NULL, "mov $1, %rbx", "set rbx to one to filter rax");
            emit(fp, NULL, "and %rbx, %rax", "filter RAX");
            return;
            break;

        case A_NEQ:
            emit(fp, NULL, "cmp %rbx, %rax", "EXPR Not Equal");
            emit(fp, NULL, "setne %al", "EXPR Not Equal");
            emit(fp, NULL, "mov $1, %rbx", "set rbx to one to filter rax");
            emit(fp, NULL, "and %rbx, %rax", "filter RAX");
            return;
            break;

        default:
            printf("WARNING SHOULD NEVER BE HERE %d ISN'T VALID!!!\n", p->operator);
            break;
    }//end operator switch
}//end Emit_Operation

//PRE: PTR to AST node that is of type A_WHILESTMT.
//POST: GAS code for the WHILESTMT with labels and jumps for its end and start for looping.
void Emit_While(ASTnode *p, FILE *fp){
    p->label = gen_Label(); //Generates the label for start of WHILE, stored in p's label.
    p->S1->label = gen_Label(); //Generates the label for end of WHILE, stored in p->S1's label.

    GOBACK = Push_Label(p->label, GOBACK); //Pushes the start label to GOBACK
    GETOUT = Push_Label(p->S1->label, GETOUT); //Pushes the end label to GETOUT

    fprintf(fp, "%s:\t\t#WHILE top target\n", p->label);


    Emit_Expr(p->S1, fp); //GAS code generated for the WHILE conditional


    emit(fp, NULL, "cmp $0, %rax", "WHILE Compare"); //Checks if the conditional was true
    fprintf(fp, "\tJE  %s\t#WHILE branch out\n", p->S1->label); //Jumps out of WHILE if conditional false


    Emit_AST(p->S2, fp); //Emits the Block attached to the while loop


    fprintf(fp, "\tjmp %s\t#WHILE jump back\n", p->label); //JUMPS back to start of WHILE if end of block reached

    fprintf(fp, "%s:\t\t#END of WHILE\n", p->S1->label); //Label at end to jump to if conditional false

    fprintf(fp, "\n"); //Line of whitespace after every loop

    //Pops both label stacks at the end of a while loop
    GOBACK = GOBACK->next; //Pops GOBACK
    GETOUT = GETOUT->next; //Pops GETOUT
}//end Emit_While


//PRE: PTR to AST node that points to Method
//POST: GAS code for the Method, %rax is set by the method special code is run for Methods
void Emit_Method_Call(ASTnode *p, FILE *fp){
    //Checks if method is an Extern
    if(p->symbol->SubType == ID_Sub_Type_ExternMethod){;
        Emit_Extern_Method_Call(p, fp);
        return;
    }

    ASTnode *params = p->S1; //Maintains pointer to method args
    int count = 8; //current register num being used for parameters

    char s[100]; //Dynamically created string used for emit

    //Evalauates each parameter, and stores it in a temporary spot
    while(params != NULL){
       // fprintf(fp, "\n");
        Emit_Expr(params->S1, fp);
        fprintf(fp, "\tmov %rax,  %d(%rsp)\t# stor arg value in our runtime stack\n", params->symbol->offset * WSIZE);
        params = params->next;
    }//end while

    //Resets params to the beginning of the arg list
    params = p->S1;


    //Goes through list of the evaluated param values and sets them to R8 and above
    while(params != NULL){
        fprintf(fp, "\tmov %d(%rsp), %rax\t#Load calc argument into RAX\n", params->symbol->offset * WSIZE);
        fprintf(fp, "\tmov %rax, %r%d\t#Load calc argument into RAX\n", count);
        count++;
        params = params->next;
    }//end while

    fprintf(fp, "\t\t# about to call a function, set up each parameter in the new activation record\n");

    sprintf(s, "CALL %s", p->name);
    emit(fp, NULL, s, "CALL to function");

}//end Emit_Method_Call




//PRE: PTR to AST node that points to Extern Method
//POST: GAS code for the Extern Method, %rax is set by the method, exits with error if unknown
void Emit_Extern_Method_Call(ASTnode *p, FILE *fp){
    char s[100]; //Dynamically created string used for printing labels
    //Generates GAS for print_string extern
    if(strcmp("print_string", p->name) == 0){
        sprintf(s, "mov $%s, %%rdi", p->S1->S1->label); //Gets the label of the string being printed
        emit(fp, NULL, s, "RDI is the label adress");
        emit(fp, NULL, "mov $0, %rax", "RAX needs to be zero");
        emit(fp, NULL, "call printf", "print a string");

        fprintf(fp, "\n");
        return;
    }//end if

    //Generates GAS for print_int extern
    if(strcmp("print_int", p->name) == 0){
        Emit_Expr(p->S1->S1, fp); //Emits the method arg

        emit(fp, NULL, "mov %rax, %rsi", "RSI needs the value");
        emit(fp, NULL, "mov $percentD, %rdi", "RDI needs to be in the int format");
        emit(fp, NULL, "mov $0, %rax", "RAX needs to be zero");
        emit(fp, NULL, "call printf", "print a number from expression");

        fprintf(fp, "\n");
        return;
    }//end if

    //Generates GAS for read_int extern
    if(strcmp("read_int", p->name) == 0){
        //Number is read into a temporary value then stuck into RAX
        emit(fp, NULL, "mov $_SCANFHOLD, %rsi", "read in a number");
        emit(fp, NULL, "mov $percentD, %rdi", "rdi has integer format for scanf");
        emit(fp, NULL, "mov $0, %rax", "No other parameters for scanf");
        emit(fp, NULL, "call __isoc99_scanf", "call read");
        emit(fp, NULL, "mov _SCANFHOLD, %rax", "bring value on STACK into RAX register");

        fprintf(fp, "\n");
        return;
    }//end if

    //If here, there is no implementation for the Extern
    fprintf(stderr, "Extern Method %s is unknown\n", p->name);
}//end Emit_Extern_Method_Call


//PRE: PTR to AST node that is assigning a variable
//POST: LVALUE data is assinged to RVALUE in memory
void Emit_Assign(ASTnode *p, FILE *fp){
    Emit_Expr(p->S2, fp); //Loads the RHS onto RAX
    fprintf(fp, "\tmov %rax, %d(%rsp)\t#Stores RHS into memory\n", p->symbol->offset * WSIZE);
    Emit_Ident(p->S1, fp); //Gets the LHS memory location
    fprintf(fp, "\tmov %d(%rsp), %rbx\t#Get RHS stored value\n", p->symbol->offset * WSIZE);
    emit(fp, NULL, "mov %rbx, (%rax)", "Assigns final score");
    fprintf(fp, "\n");
}//end Emit_Assign



//PRE: PTR to a LVALUE or RVALUE
//POST: RAX is the memory location of the ID
void Emit_Ident(ASTnode *p, FILE *fp){
    char s[100]; //Dynamically created string for emit()

    //If an array calculate internal offset
    if(p->symbol->SubType == ID_Sub_Type_Array){
       
        Emit_Expr(p->S1, fp); //Evaluates the expression for the array index
        emit(fp, NULL, "mov %rax, %rbx", "The array component");
        
        //Shifts the LEFT the LOGSIZE of it so that it is effectively multiplied by WSIZE
        emit(fp, NULL, "shl $3, %rbx", "Multiply word size for the array reference");
        
        //Checks if the array is local or global, memory address referenced will change depending on this
            //If global accessed by the name of the var
        if(p->symbol->level == 0)
            fprintf(fp, "\tmov $%s, %rax\t#Load global variable from data segment\n", p->name);
            //else local accessed via the identifier offset
        else{
            emit(fp, NULL, "mov $0, %rax", "Get Identifier Offset");
            emit(fp, NULL, "add %rsp, %rax", "Have a direct reference to memory");
        }
            
        emit(fp, NULL, "add %rbx, %rax", "Add on rbx for the array reference");
        return;//Exits method
    }//end if for arrays

    //Checks if variable is global or local, memory location that is pulled from will differ
        //If global accessed by the name of the var
    if(p->symbol->level == 0){
        sprintf(s, "mov $%s, %%rax", p->symbol->name);
        emit(fp, NULL, s, "Load Global Variable Address into RAX");
    }//end if for global vars
        //else local accessed by the identifier offset
    else{
        sprintf(s, "mov $%d, %%rax", p->symbol->offset * WSIZE);
        emit(fp, NULL, s, "Get identifier offset");
        emit(fp, NULL, "add %rsp, %rax", "Direct reference to memory");
    }//end if for local vars
}//end Emit_Ident




//PRE: PTR to A_IF node alongside a FILE PTR
//POST: GAS code to compare the node conditional and labels to jump its else and end.
void Emit_If(ASTnode *p, FILE *fp){
    char s[100]; //Dynamically created string for emit()
    
    Emit_Expr(p->S1->S1, fp); //Emits the IF conditional

    emit(fp, NULL, "cmp $0, %rax", "IF Compare"); //Checks if the conditional was true

    p->S1->label = gen_Label(); //Creates a label for the IF body
    p->label = gen_Label(); //Creates a label for the ELSE body

    fprintf(fp, "\tJE\t%s\t# IF branch to ELSE part\n", p->S1->label);

    Emit_AST(p->S1->S2, fp); //Emits the IF BODY

    fprintf(fp, "\tJMP\t%s\t# IF END\n", p->label);

    emit(fp, p->S1->label, NULL, "ELSE target");

    //Checks that there is an ELSE body
    if(p->S2 != NULL)
        Emit_AST(p->S2->S1, fp); //Emits the ELSE BODY

    emit(fp, p->label, NULL, "END of IF");

    fprintf(fp, "\n"); //Line of whitespace after IF GAS code
}//end Emit_If




//Helper Function for clean printing
//Pre: Requires a FILE pointer and a NULL or non-null char pointer to label, action, comment
//Post: Produces formatted GAS code in FILE
void emit(FILE *fp, char *label, char *action, char *comment){
    if(label == NULL){
        //NO label
        if(action == NULL){
            //NO label NO action
            if (comment == NULL){
                //NO label NO action NO comment
                fprintf(fp, "\n");
            }//end if
            else{
                //NO label NO action YES comment
                fprintf(fp, "\t# %s\n", comment);
            }//end else
        }//end if
        else{
            //NO label YES action
            if (comment == NULL){
                //NO label YES action NO comment
                fprintf(fp, "\t%s\n", action);
            }//end if

            else{
                //NO label YES action YES comment
                fprintf(fp, "\t%s\t# %s\n", action, comment);
            }//end else
        }//end else
    }//end if
    else {
        //YES label
        if(action == NULL){
            //YES label NO action
            if (comment == NULL){
                //YES label NO action NO comment
                fprintf(fp, "%s:\n", label);
            }//end if

            else{
                //YES label NO action YES comment
                fprintf(fp, "%s:\t# %s\n", label, comment);
            }//end else

        }//end if

        else{
            //YES label YES action
            if (comment == NULL){
                //YES label YES action NO comment
                fprintf(fp, "%s:\t%s\n", label, action);
            }//end if

            else{
                //YES label YES action YES comment
                fprintf(fp, "%s:\t%s\t# %s\n", label, action, comment);
            }//end else

        }//end else

    }//end of label

}//end emit()
